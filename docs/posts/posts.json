[
  {
    "path": "posts/2022-04-26-another-test/",
    "title": "Plotting with ggplot2",
    "description": "In this post we will use histograms to find groups in our data.",
    "author": [
      {
        "name": "Guilherme Bastos Gomes",
        "url": "https://gbastosg.github.io/guilhermesportfolio/"
      }
    ],
    "date": "2022-04-26",
    "categories": [],
    "contents": "\r\nHello!\r\nNow we are going to analyse some data using plots\r\nIn\r\nthis post we have done some wrangling to form groups and analyse\r\nthem in a numerical way. Today we are going to create some plots that\r\nhelps us with the interpretation of data\r\nWe will remain using the data from mpg data set included\r\nin the ggplot package, so let’s load the\r\ntidyverse:\r\nlibrary(tidyverse)\r\nTo a better understandment of the data, click on the link to read\r\nabout it in the previous post.\r\n“How motors improved\r\nduring these years?”\r\nTo answer this question, we can plot the efficiency of the motors\r\n(measured by city miles per gallons), let’s use ggplot2 to\r\ndo that.\r\nHistograms\r\nHistograms are also known as frequency plots, and they show us how\r\nmany times a value appears in our data set:\r\nmpg %>%\r\n  ggplot(aes(x = cty)) +\r\n  geom_histogram(binwidth = 1)\r\n\r\n\r\n\r\nNotice that in the Y axis is the count of how many times that value\r\nappears, while in the X axis we can check the values of cty\r\n(city miles per gallons)\r\nWe can built more histogram and also compare them:\r\n\r\n\r\n\r\nmpg %>%\r\n  filter(year == 1999) %>%\r\n  ggplot(aes(x = cty)) +\r\n  geom_histogram()\r\n\r\n\r\n\r\nmpg %>%\r\n  filter(year == 2008) %>%\r\n  ggplot(aes(x = cty)) +\r\n  geom_histogram()\r\n\r\n\r\n\r\nNow we can use the Patchwork package to combine the\r\nvisualisation of both plots:\r\nlibrary(patchwork)\r\n\r\nhist1999 <- mpg %>%\r\n  filter(year == 1999) %>%\r\n  ggplot(aes(x = cty)) +\r\n  geom_histogram() +\r\n  xlab(\"1999\")\r\n  \r\nhist2008 <- mpg %>%\r\n  filter(year == 2008) %>%\r\n  ggplot(aes(x = cty)) +\r\n  geom_histogram() +\r\n  xlab(\"2008\")\r\n  \r\nhist1999  + hist2008\r\n\r\n\r\n\r\nInteresting, right?\r\nWe can also change the colour of our plots to improve comparison:\r\n\r\nhist1999 <- mpg %>%\r\n  filter(year == 1999) %>%\r\n  ggplot(aes(x = cty)) +\r\n  geom_histogram(color = \"Blue\", binwidth = 1) +\r\n  xlab(\"1999\")\r\n  \r\nhist2008 <- mpg %>%\r\n  filter(year == 2008) %>%\r\n  ggplot(aes(x = cty)) +\r\n  geom_histogram(color = \"Red\", binwidth = 1) +\r\n  xlab(\"2008\")\r\n  \r\nhist1999  + hist2008\r\n\r\n\r\n\r\nWatching it like this makes it easier to conclude that cars have\r\nbecome more efficient during years.\r\nThere are other interesting ways of improving the quality of our\r\nhistograms, check how they come out with colours:\r\ncolour_hist1999 <- mpg %>%\r\n  filter(year == 1999) %>%\r\n  ggplot(aes(x = cty)) +\r\n  geom_histogram(colour = \"Firebrick\", binwidth = 1, fill = \"MidnightBlue\") +\r\n  xlab(\"1999\")\r\n  \r\ncolour_hist2008 <- mpg %>%\r\n  filter(year == 2008) %>%\r\n  ggplot(aes(x = cty)) +\r\n  geom_histogram(colour = \"dodgerblue\", binwidth = 1, fill = \"Firebrick\") +\r\n  xlab(\"2008\")\r\n  \r\ncolor_hist1999  + color_hist2008\r\n\r\n\r\n\r\nA similar type of plot that also has plenty of information about\r\ngroups is the density plot.\r\nDensity plots\r\nWith ggplot we can plot density of out data in a simple\r\nway:\r\n\r\n\r\n\r\nlibrary(tidyverse)\r\nmpg %>%\r\n  ggplot(aes(x = cty)) +\r\n  geom_density(aes(colour = as.factor(year))) +\r\n  xlab(\"Density Plot\")\r\nIn this kind of plot we can see the presence of many subgroups, the\r\narea under the curves of each subgroups sums to 1. This allows us to\r\ncompare subgroups of diferent sizes.\r\nIt’s also possible to optimise visualisation of this plot, check the\r\nargumentsof the funtion geom_density() and explore what it\r\nis capable of doing!\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-04-26-another-test/another-test_files/figure-html5/unnamed-chunk-1-1.png",
    "last_modified": "2022-04-30T05:15:24-03:00",
    "input_file": "another-test.knit.md"
  },
  {
    "path": "posts/2022-04-24-plotando-com-ggplot2/",
    "title": "Histogramas com ggplot2",
    "description": "Neste post usaremos histogramas para compreender grupos nos dados.",
    "author": [
      {
        "name": "Guilherme Bastos Gomes",
        "url": "https://gbastosg.github.io/guilhermesportfolio/"
      }
    ],
    "date": "2022-04-24",
    "categories": [],
    "contents": "\r\nOlá!\r\nAgora vamos trabalhar com alguns gráficos para análisar nossos\r\ndados\r\nNeste\r\npost fizemos algumas manipulações para formar grupos e entender os\r\ndados. Hoje faremos alguns gráficos para ajudar na interpretação.\r\nContinuaremos usando os dados mpg (miles per gallon)\r\nincluso no pacote ggplot, por isso vamos carregar o tidyverse:\r\nlibrary(tidyverse)\r\nPara compreender mais sobre os dados, clique no link do post\r\nanterior\r\nSerá\r\nque os motores ficaram mais eficientes ao longo do tempo?\r\nPara responder essa pergunta, podemos plotar a eficiencia dos motores\r\n(aqui medida pelo gasto de galões por milhas percorridas), para plotar\r\nusamos as funções embutidas no pacote ggplot2.\r\nHistogramas\r\nHistogramas são também conhecidos como gráficos de frequência e nos\r\nmostram quantas vezes um valor aparece em nosso data set:\r\nmpg %>%\r\n  ggplot(aes(x = cty)) +\r\n  geom_histogram(binwidth = 1)\r\n\r\n\r\n\r\nPerceba que no eixo Y está a contagem de quantas vezes aquele valor\r\naparece, enquanto no eixo X podemos ver os valores de cty\r\n(a quantidade de milhas que um carro percorre por galão de\r\ncombustível)\r\nPodemos contruir outros histogramas e compará-los:\r\n\r\n\r\n\r\nmpg %>%\r\n  filter(year == 1999) %>%\r\n  ggplot(aes(x = cty)) +\r\n  geom_histogram()\r\n\r\n\r\n\r\nmpg %>%\r\n  filter(year == 2008) %>%\r\n  ggplot(aes(x = cty)) +\r\n  geom_histogram()\r\n\r\n\r\n\r\nAgora podemos usar o pacote Patchwork para visualizar os\r\ndois gráficos no mesmo quadro:\r\nlibrary(patchwork)\r\n\r\nhist1999 <- mpg %>%\r\n  filter(year == 1999) %>%\r\n  ggplot(aes(x = cty)) +\r\n  geom_histogram() +\r\n  xlab(\"1999\")\r\n  \r\nhist2008 <- mpg %>%\r\n  filter(year == 2008) %>%\r\n  ggplot(aes(x = cty)) +\r\n  geom_histogram() +\r\n  xlab(\"2008\")\r\n  \r\nhist1999  + hist2008\r\n\r\n\r\n\r\nInteressante, não?\r\nPodemos também mudar a cor dos nossos plots para melhorar a\r\ncomparação:\r\n\r\nhist1999 <- mpg %>%\r\n  filter(year == 1999) %>%\r\n  ggplot(aes(x = cty)) +\r\n  geom_histogram(color = \"Blue\", binwidth = 1) +\r\n  xlab(\"1999\")\r\n  \r\nhist2008 <- mpg %>%\r\n  filter(year == 2008) %>%\r\n  ggplot(aes(x = cty)) +\r\n  geom_histogram(color = \"Red\", binwidth = 1) +\r\n  xlab(\"2008\")\r\n  \r\nhist1999  + hist2008\r\n\r\n\r\n\r\nObservando dessa maneira parece até fácil concluir que os carros se\r\ntornaram mais eficientes ao longo dos anos.\r\nExistem formas interessantes de aumentar a qualidade dos nossos\r\nhistogramas. Veja como ficam com cores:\r\ncolor_hist1999 <- mpg %>%\r\n  filter(year == 1999) %>%\r\n  ggplot(aes(x = cty)) +\r\n  geom_histogram(color = \"Firebrick\", binwidth = 1, fill = \"MidnightBlue\") +\r\n  xlab(\"1999\")\r\n  \r\ncolor_hist2008 <- mpg %>%\r\n  filter(year == 2008) %>%\r\n  ggplot(aes(x = cty)) +\r\n  geom_histogram(color = \"dodgerblue\", binwidth = 1, fill = \"Firebrick\") +\r\n  xlab(\"2008\")\r\n  \r\ncolor_hist1999  + color_hist2008\r\n\r\n\r\n\r\nUm tipo de gráfico similar e que também nos entrega informações de\r\nfrequências e grupos, é o plot de densidade.\r\nPlots de densidade\r\nCom o ggplot podemos fazer um gráfico de densidade de forma bem\r\nsimples:\r\n\r\n\r\n\r\nlibrary(tidyverse)\r\nmpg %>%\r\n  ggplot(aes(x = cty)) +\r\n  geom_density(aes(colour = as.factor(year))) +\r\n  xlab(\"Density Plot\")\r\nNesse tipo de plot podemos ver a presença de múltiplos subgrupos, a\r\nárea embaixo da curva para cada sub-grupo soma até 1. Isso nos permite\r\ncomparar subgrupos de diferentes tamanhos.\r\nTambém é possível otimizar a visualização desse tipo de gráfico, mexa\r\nnos argumentos da função geom_density() e explore o que ela\r\né capaz de fazer!\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-04-24-plotando-com-ggplot2/plotando-com-ggplot2_files/figure-html5/unnamed-chunk-1-1.png",
    "last_modified": "2022-04-30T05:14:45-03:00",
    "input_file": "plotando-com-ggplot2.knit.md"
  },
  {
    "path": "posts/2022-04-23-using-the-tidyverse-functions/",
    "title": "Using the tidyverse functions",
    "description": "In this post I combine some of the tidyverse functions to obtain interesting stats from the data. The main idea is to work with the tools we've already used. In the case of a new tool showing up, I will explain it, but always remeber that you can read about R functions by tiping \"?nameofthefunction\" in the console!",
    "author": [
      {
        "name": "Guilherme Bastos Gomes",
        "url": "https://gbastosg.github.io/guilhermesportfolio/"
      }
    ],
    "date": "2022-04-23",
    "categories": [],
    "contents": "\r\nHello! In this post I will use some of the functions from tidyverse to wrangle built-in R data\r\nRemembering that in this post I’ve explained about each of these functions!\r\nToday we will use the dataset mpg from tidyverse, so let’s start loading the package:\r\nlibrary(tidyverse)\r\nLet’s check what exists in the data.frame, or have a glimpse() on it:\r\nglimpse(mpg)\r\n\r\nRows: 234\r\nColumns: 11\r\n$ manufacturer <chr> \"audi\", \"audi\", \"audi\", \"audi\", \"audi\", \"audi\", \"audi\", \"audi\", \"audi\"~\r\n$ model        <chr> \"a4\", \"a4\", \"a4\", \"a4\", \"a4\", \"a4\", \"a4\", \"a4 quattro\", \"a4 quattro\", ~\r\n$ displ        <dbl> 1.8, 1.8, 2.0, 2.0, 2.8, 2.8, 3.1, 1.8, 1.8, 2.0, 2.0, 2.8, 2.8, 3.1, ~\r\n$ year         <int> 1999, 1999, 2008, 2008, 1999, 1999, 2008, 1999, 1999, 2008, 2008, 1999~\r\n$ cyl          <int> 4, 4, 4, 4, 6, 6, 6, 4, 4, 4, 4, 6, 6, 6, 6, 6, 6, 8, 8, 8, 8, 8, 8, 8~\r\n$ trans        <chr> \"auto(l5)\", \"manual(m5)\", \"manual(m6)\", \"auto(av)\", \"auto(l5)\", \"manua~\r\n$ drv          <chr> \"f\", \"f\", \"f\", \"f\", \"f\", \"f\", \"f\", \"4\", \"4\", \"4\", \"4\", \"4\", \"4\", \"4\", ~\r\n$ cty          <int> 18, 21, 20, 21, 16, 18, 18, 18, 16, 20, 19, 15, 17, 17, 15, 15, 17, 16~\r\n$ hwy          <int> 29, 29, 31, 30, 26, 26, 27, 26, 25, 28, 27, 25, 25, 25, 25, 24, 25, 23~\r\n$ fl           <chr> \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", ~\r\n$ class        <chr> \"compact\", \"compact\", \"compact\", \"compact\", \"compact\", \"compact\", \"com~\r\nInteresting, huh? It’s possible to see that in this data.frame we can find 11 columns and 234 rows. To understand even more about this data you can type ?mpg in the console, but here is a brief explanation:\r\nmpg\r\nFuel economy data from 1999 to 2008 for 38 popular models of cars.\r\nIt is possible to use the function colnames() to check what is in it:\r\ncolnames(mpg)\r\n\r\n[1] \"manufacturer\" \"model\"        \"displ\"        \"year\"         \"cyl\"         \r\n[6] \"trans\"        \"drv\"          \"cty\"          \"hwy\"          \"fl\"          \r\n[11] \"class\"\r\nAnother pretty interesting way of receiving some stats happens by using the function summary()\r\nsummary()\r\nThis is a very generic functio from R base, and serves mainly to obtain a summary (yeah) with statistics of an object:\r\nsummary(mpg)\r\n\r\n manufacturer          model               displ            year           cyl       \r\n Length:234         Length:234         Min.   :1.600   Min.   :1999   Min.   :4.000  \r\n Class :character   Class :character   1st Qu.:2.400   1st Qu.:1999   1st Qu.:4.000  \r\n Mode  :character   Mode  :character   Median :3.300   Median :2004   Median :6.000  \r\n                                       Mean   :3.472   Mean   :2004   Mean   :5.889  \r\n                                       3rd Qu.:4.600   3rd Qu.:2008   3rd Qu.:8.000  \r\n                                       Max.   :7.000   Max.   :2008   Max.   :8.000  \r\n    trans               drv                 cty             hwy             fl           \r\n Length:234         Length:234         Min.   : 9.00   Min.   :12.00   Length:234        \r\n Class :character   Class :character   1st Qu.:14.00   1st Qu.:18.00   Class :character  \r\n Mode  :character   Mode  :character   Median :17.00   Median :24.00   Mode  :character  \r\n                                       Mean   :16.86   Mean   :23.44                     \r\n                                       3rd Qu.:19.00   3rd Qu.:27.00                     \r\n                                       Max.   :35.00   Max.   :44.00                     \r\n    class          \r\n Length:234        \r\n Class :character  \r\n Mode  :character\r\n \r\nWow! This is a lot of information our data with only one function!\r\n\r\nLet’s now combine some of the functions from tidyverse to obtain even more stats!\r\n\r\ncombining functions using a pipe “%>%”\r\nmpg %>%\r\n  select(motor_type = displ,\r\n  year, \r\n  city_miles_per_gallon = cty, \r\n  highway_miles_per_gallon = hwy) %>%\r\n  group_by(year) %>%\r\n  summarise(mean_cty_miles_per_gallon = mean(city_miles_per_gallon), \r\n  mean_hwy_miles_per_gallon = mean(highway_miles_per_gallon))\r\nHere we see that in average, cars from 1999 used to run 0.3 more miles per gallon in the city than in 2008, although the average does not changes much from the average on the hailway:\r\nyear\r\nmean_cty_miles_per_gallon\r\nmean_hwy_miles_per_gallon\r\n1999\r\n17.0\r\n23.4\r\n2008\r\n16.7\r\n23.5\r\nNotice how inside the select() function we could add the name of columns that would appear in our sub set.\r\nSo inside the summarise() we should include those new names\r\n\r\nBut how about the many types of motors?\r\n\r\nmpg %>%\r\n  select(motor_type = displ,\r\n  year, \r\n  city_miles_per_gallon = cty, \r\n  highway_miles_per_gallon = hwy) %>%\r\n  group_by(motor_type, year) %>%\r\n  summarise(mean_cty_miles_per_gallon = mean(city_miles_per_gallon), \r\n  mean_hwy_miles_per_gallon = mean(highway_miles_per_gallon))\r\nAgora agrupamos por duas colunas, primeiro por tipo do motor, segundo pelo ano:\r\nmotor_type\r\nyear\r\nmean_cty_miles_per_gallon\r\nmean_hwy_miles_per_gallon\r\n1.6\r\n1999\r\n24.8\r\n31.6\r\n1.8\r\n1999\r\n20.7\r\n29.4\r\n1.8\r\n2008\r\n25.8\r\n35.6\r\n1.9\r\n1999\r\n32.3\r\n43\r\n2\r\n1999\r\n19.8\r\n27.5\r\n2\r\n2008\r\n20.5\r\n28.7\r\n2.2\r\n1999\r\n20.7\r\n27.3\r\n2.4\r\n1999\r\n18.8\r\n26.7\r\n2.4\r\n2008\r\n21.3\r\n30.7\r\n2.5\r\n1999\r\n18.3\r\n25.5\r\n2.5\r\n1999\r\n18.3\r\n25.5\r\nGreat, now we have comparisons about motor types! We can also arrange() our table:\r\nmpg %>%\r\n  select(motor_type = displ,\r\n  year, \r\n  city_miles_per_gallon = cty, \r\n  highway_miles_per_gallon = hwy) %>%\r\n  group_by(motor_type, year) %>%\r\n  summarise(mean_cty_miles_per_gallon = mean(city_miles_per_gallon), \r\n  mean_hwy_miles_per_gallon = mean(highway_miles_per_gallon)) %>%\r\n  arrange(year)\r\nCool, now that we have our organized data we can split two more data sets from this one, by using a filter we can include only those cars from 1999 and 2008 in two separate data sets:\r\nmpg_1999 <- mpg %>%\r\n  select(motor_type = displ,\r\n  year, \r\n  city_miles_per_gallon = cty, \r\n  highway_miles_per_gallon = hwy) %>%\r\n  group_by(motor_type, year) %>%\r\n  summarise(mean_cty_miles_per_gallon = mean(city_miles_per_gallon), \r\n  mean_hwy_miles_per_gallon = mean(highway_miles_per_gallon)) %>%\r\n  arrange(year) %>%\r\n  filter(year == 1999)\r\nmpg_2008 <- mpg %>%\r\n  select(motor_type = displ,\r\n  year, \r\n  city_miles_per_gallon = cty, \r\n  highway_miles_per_gallon = hwy) %>%\r\n  group_by(motor_type, year) %>%\r\n  summarise(mean_cty_miles_per_gallon = mean(city_miles_per_gallon), \r\n  mean_hwy_miles_per_gallon = mean(highway_miles_per_gallon)) %>%\r\n  arrange(year) %>%\r\n  filter(year == 2008)\r\nThis is pretty useful when we are dealing with a lot of data and to improve our analyses.\r\nHave a look in both sub sets and find out ways of comparing those values.\r\nDid the cars became more or less efficient in time?\r\n\r\nIn the next post: One of the easiest ways of comparing data is by using plots. Next post I’m going to use ggplot to create some of them and compare results.\r\n\r\nThank you for your time!\r\nFollow me on twitter: @gimbgomes\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2022-04-24T19:01:07-03:00",
    "input_file": {}
  },
  {
    "path": "posts/2022-04-20-combinando-as-ferramentas-do-tidyverse/",
    "title": "Combinando as ferramentas do tidyverse",
    "description": "Neste post combino as funções do tidyverse para obter estatísticas interessantes sobre os dados. A ideia principal é trabalhar com as ferramentas já explicadas em outros posts. Caso uma ferramenta nova apareça, explicarei, mas lembre que é possível ler sobre as funções do R digitando \"?nomedafunção\" no console!",
    "author": [
      {
        "name": "Guilherme Bastos Gomes",
        "url": "https://gbastosg.github.io/guilhermesportfolio/"
      }
    ],
    "date": "2022-04-20",
    "categories": [],
    "contents": "\r\nOlá!\r\nNeste post usarei diversas funções do tidyverse para manipular dados que\r\njá estão presentes no R\r\nLembrando que neste\r\npost expliquei sobre cada uma dessas funções!\r\nHoje vamos combinar todas elas para manipular os dados e melhorar as\r\nanálises.\r\nPara isso, usaremos o dataset mpg embutido no tidyverse,\r\nentão começamos carregando o pacote:\r\nlibrary(tidyverse)\r\nDê uma checada no que existe no data.frame, usando a função\r\nglimpse():\r\nglimpse(mpg)\r\n\r\nRows: 234\r\nColumns: 11\r\n$ manufacturer <chr> \"audi\", \"audi\", \"audi\", \"audi\", \"audi\", \"audi\", \"audi\", \"audi\", \"audi\"~\r\n$ model        <chr> \"a4\", \"a4\", \"a4\", \"a4\", \"a4\", \"a4\", \"a4\", \"a4 quattro\", \"a4 quattro\", ~\r\n$ displ        <dbl> 1.8, 1.8, 2.0, 2.0, 2.8, 2.8, 3.1, 1.8, 1.8, 2.0, 2.0, 2.8, 2.8, 3.1, ~\r\n$ year         <int> 1999, 1999, 2008, 2008, 1999, 1999, 2008, 1999, 1999, 2008, 2008, 1999~\r\n$ cyl          <int> 4, 4, 4, 4, 6, 6, 6, 4, 4, 4, 4, 6, 6, 6, 6, 6, 6, 8, 8, 8, 8, 8, 8, 8~\r\n$ trans        <chr> \"auto(l5)\", \"manual(m5)\", \"manual(m6)\", \"auto(av)\", \"auto(l5)\", \"manua~\r\n$ drv          <chr> \"f\", \"f\", \"f\", \"f\", \"f\", \"f\", \"f\", \"4\", \"4\", \"4\", \"4\", \"4\", \"4\", \"4\", ~\r\n$ cty          <int> 18, 21, 20, 21, 16, 18, 18, 18, 16, 20, 19, 15, 17, 17, 15, 15, 17, 16~\r\n$ hwy          <int> 29, 29, 31, 30, 26, 26, 27, 26, 25, 28, 27, 25, 25, 25, 25, 24, 25, 23~\r\n$ fl           <chr> \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", ~\r\n$ class        <chr> \"compact\", \"compact\", \"compact\", \"compact\", \"compact\", \"compact\", \"com~\r\nVemos que existem 11 colunas e 234 linhas, é um data set bem\r\ninteressante! Para saber mais a respeito desses dados, basta digitar\r\n?mpg no console, mas aqui vai uma breve explicação:\r\nmpg\r\nDados sobre a economia de combustível de carros populares de 1999 até\r\n2008.\r\nÉ possível usar a função colnames() para observar as\r\ncolunas do df:\r\ncolnames(mpg)\r\n\r\n[1] \"manufacturer\" \"model\"        \"displ\"        \"year\"         \"cyl\"         \r\n[6] \"trans\"        \"drv\"          \"cty\"          \"hwy\"          \"fl\"          \r\n[11] \"class\"\r\nUma forma bem interessante de receber algumas estatísticas é usar a\r\nfunção summary()\r\nsummary()\r\nEssa é uma função bem generica do R base, e serve principalmente para\r\nobter um resumo com estatisticas de um objeto:\r\nsummary(mpg)\r\n\r\n manufacturer          model               displ            year           cyl       \r\n Length:234         Length:234         Min.   :1.600   Min.   :1999   Min.   :4.000  \r\n Class :character   Class :character   1st Qu.:2.400   1st Qu.:1999   1st Qu.:4.000  \r\n Mode  :character   Mode  :character   Median :3.300   Median :2004   Median :6.000  \r\n                                       Mean   :3.472   Mean   :2004   Mean   :5.889  \r\n                                       3rd Qu.:4.600   3rd Qu.:2008   3rd Qu.:8.000  \r\n                                       Max.   :7.000   Max.   :2008   Max.   :8.000  \r\n    trans               drv                 cty             hwy             fl           \r\n Length:234         Length:234         Min.   : 9.00   Min.   :12.00   Length:234        \r\n Class :character   Class :character   1st Qu.:14.00   1st Qu.:18.00   Class :character  \r\n Mode  :character   Mode  :character   Median :17.00   Median :24.00   Mode  :character  \r\n                                       Mean   :16.86   Mean   :23.44                     \r\n                                       3rd Qu.:19.00   3rd Qu.:27.00                     \r\n                                       Max.   :35.00   Max.   :44.00                     \r\n    class          \r\n Length:234        \r\n Class :character  \r\n Mode  :character\r\n \r\nPerceba quanta informação recebemos com apenas uma função!\r\n\r\nVamos misturar algumas funções do tidyverse para obter ainda mais\r\nstats!\r\n\r\nmisturando as funções com o\r\npipe “%>%”\r\nmpg %>%\r\n  select(tipo_de_motor = displ,\r\n  ano = year, \r\n  galao_milhas_cidade = cty, \r\n  galao_milhas_estrada = hwy) %>%\r\n  group_by(ano) %>%\r\n  summarise(media_milhas_por_galao_cidade = mean(galao_milhas_cidade), \r\n  media_milhas_por_galao_estrada = mean(galao_milhas_estrada))\r\nVeja que interessante, parece que em média os motores passaram a\r\npercorrer menos milhas (0.3 a menos) por galão nas cidades, enquanto na\r\nestrada esse valor aumentou em 0.1:\r\nano\r\nmedia_gasto_galao_cidade\r\nmedia_gasto_galao_estrada\r\n1999\r\n17.0\r\n23.4\r\n2008\r\n16.7\r\n23.5\r\nPerceba como dentro da função select() pudemos criar o\r\nnome das colunas que apareceram no subset selecionado.\r\nSendo assim, dentro da função summarise() temos que\r\ntrabalhar com os novos nomes.\r\n\r\nSerá que existe uma relação entre o tipo do motor daquele ano e o\r\ngasto de gasolina?\r\n\r\nmpg %>%\r\n  select(tipo_de_motor = displ,\r\n  ano = year, \r\n  galao_milhas_cidade = cty, \r\n  galao_milhas_estrada = hwy) %>%\r\n  group_by(tipo_de_motor, ano) %>%\r\n  summarise(media_milhas_por_galao_cidade = mean(galao_milhas_cidade), \r\n  media_milhas_por_galao_estrada = mean(galao_milhas_estrada))\r\nAgora agrupamos por duas colunas, primeiro por tipo do motor, segundo\r\npelo ano:\r\ntipo_de_motor\r\nano\r\nmedia_gasto_galao_cidade\r\nmedia_gasto_galao_estrada\r\n1.6\r\n1999\r\n24.8\r\n31.6\r\n1.8\r\n1999\r\n20.7\r\n29.4\r\n1.8\r\n2008\r\n25.8\r\n35.6\r\n1.9\r\n1999\r\n32.3\r\n43\r\n2\r\n1999\r\n19.8\r\n27.5\r\n2\r\n2008\r\n20.5\r\n28.7\r\n2.2\r\n1999\r\n20.7\r\n27.3\r\n2.4\r\n1999\r\n18.8\r\n26.7\r\n2.4\r\n2008\r\n21.3\r\n30.7\r\n2.5\r\n1999\r\n18.3\r\n25.5\r\n2.5\r\n1999\r\n18.3\r\n25.5\r\nMas nossa tabela ainda está bagunçada, vamos arrumar com um\r\narrange():\r\nmpg %>%\r\n  select(tipo_de_motor = displ,\r\n  ano = year, \r\n  galao_milhas_cidade = cty, \r\n  galao_milhas_estrada = hwy) %>%\r\n  group_by(tipo_de_motor, ano) %>%\r\n  summarise(media_milhas_por_galao_cidade = mean(galao_milhas_cidade), \r\n  media_milhas_por_galao_estrada = mean(galao_milhas_estrada)) %>%\r\n  arrange((ano))\r\nManeiro, agora que temos nosso dado bem organizado podemos separar os\r\ncarros de 1999 daqueles de 2008 usando um filtro e salvar esse resultado\r\nnum novo objeto:\r\nmpg_1999 <- mpg %>%\r\n  select(tipo_de_motor = displ,\r\n  ano = year, \r\n  galao_milhas_cidade = cty, \r\n  galao_milhas_estrada = hwy) %>%\r\n  group_by(tipo_de_motor, ano) %>%\r\n  summarise(media_milhas_por_galao_cidade = mean(galao_milhas_cidade), \r\n  media_milhas_por_galao_estrada = mean(galao_milhas_estrada)) %>%\r\n  arrange((ano)) %>%\r\n  filter(ano == 1999)\r\nmpg_2008 <- mpg %>%\r\n  select(tipo_de_motor = displ,\r\n  ano = year, \r\n  galao_milhas_cidade = cty, \r\n  galao_milhas_estrada = hwy) %>%\r\n  group_by(tipo_de_motor, ano) %>%\r\n  summarise(media_milhas_por_galao_cidade = mean(galao_milhas_cidade), \r\n  media_milhas_por_galao_estrada = mean(galao_milhas_estrada)) %>%\r\n  arrange((ano)) %>%\r\n  filter(ano == 2008)\r\nAgora construímos sub sets do nosso conjunto original, o que é muito\r\nútil quando estamos realizando análises.\r\nDê uma olhada em ambos sub data sets e pense em maneiras de comparar\r\nesses valores.\r\n\r\nNo próximo post: Uma das formas mais fáceis de se comparar grupos de\r\ndados é usar gráficos. No próximo post usarei gráficos do ggplot para\r\nmostrar como fazer tais comparações.\r\n\r\nObrigado por chegar até aqui!\r\nMe segue no twitter: @gimbgomes\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2022-05-01T07:29:10-03:00",
    "input_file": "combinando-as-ferramentas-do-tidyverse.knit.md"
  },
  {
    "path": "posts/2022-04-19-about-the-structure-of-variables/",
    "title": "About the structure of variables",
    "description": "Variables are everywhere, let's understand a bit more about their structures in the R programming language.",
    "author": [
      {
        "name": "Guilherme Bastos Gomes",
        "url": "https://gbastosg.github.io/guilhermesportfolio/"
      }
    ],
    "date": "2022-04-19",
    "categories": [],
    "contents": "\r\nHello!\r\nIn this post I am going to briefly write about the structure of\r\nvariables\r\n\r\nVariable is everything that varies, or can vary.\r\n\r\nBut what is it in practice?\r\nEverytime we create an object, we are also creating a kind of\r\nvariable\r\nIn fact, it’s good to remember that:\r\n\r\n\\(\\color{blue}{\\text{\"Everything that\r\nexists in R is an object.\"}}\\) ~John M. Chambers\r\n\r\nSo basically we will be dealing with variables all the time!\r\nTo understand the 4 main types of variables, you should create the\r\nfollowing objects in your workspace:\r\nlogical <- TRUE\r\ncharacter <- \"text\"\r\nnumeric <- 1\r\nfactor <- as.factor(c(“I”, “Am”, “a”, “factor”))\r\nEach object is interpreted in a different way by the language, let’s\r\nuse the function class() to understand how each variable\r\nbehaves:\r\nclass()\r\nType in the following after creating the objects:\r\nclass(logical)\r\nclass(character)\r\nclass(numeric)\r\nclass(factor)\r\nYou should have the following answers:\r\n[1] \"logical\"\r\n[1] \"character\"\r\n[1] \"numeric\"\r\n[1] \"factor\"\r\nEach object belongs to a different class, therefore should be treated\r\nas such.\r\nWhat each of these\r\nstructures means?\r\nlogical\r\nlogical (ou lógica): Boolean/binary , it’s always\r\nTRUE or FALSE\r\ncharacter\r\ncharacter (or string): simple text, including\r\nsymbols and numbers inside of quotation marks \"text\",\r\n\"this is a text\", \"th1s 1s 4ls0 a t3xt\".\r\nnumeric\r\nnumeric (numérico): Literally numbers. Mathematic\r\noperators can be used here.\r\nRemembering that in truth programming languages are just fancy\r\ncalculators:\r\n+ add\r\n- subtract\r\n* multiply\r\n/ divide\r\n^ exponentiation\r\nfactor\r\nfactor: Numbers or strings (text) ORDERED\r\nsomehow:\r\nThis is a factor:\r\nas.factor(c(\"I\", \"am\", \"a\", \"factor\"))\r\nThis is also a factor:\r\nas.factor(c(1, 2, 3, 4))\r\nThe word ORDER is the most important one here to define factors\r\nThese are the main 4 structures that will appear in your\r\nanalyses!\r\nThank you for your time!\r\nFollow me on twitter: @gimbgomes\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2022-05-01T07:26:18-03:00",
    "input_file": "about-the-structure-of-variables.knit.md"
  },
  {
    "path": "posts/2022-04-19-sobre-a-estrutura-das-variveis/",
    "title": "Sobre a estrutura das variáveis",
    "description": "Variáveis estão em todos os lugares, vamos entender um pouco mais sobre suas estruturas em R.",
    "author": [
      {
        "name": "Guilherme Bastos Gomes",
        "url": "https://gbastosg.github.io/guilhermesportfolio/"
      }
    ],
    "date": "2022-04-19",
    "categories": [],
    "contents": "\r\nOlá!\r\nNeste post irei brevemente escrever sobre a estrutura de variáveis\r\n\r\nvariável é aquilo que varia, ou pode variar.\r\n\r\nMas o que é uma variável na prática?\r\nToda vez que criamos um objeto, estamos criando um tipo de\r\nvariável\r\nDe fato, é bom lembrar que:\r\n\r\n\\(\\color{blue}{\\text{\"Tudo o que\r\nexiste em R é um objeto.\"}}\\) ~John M. Chambers\r\n\r\nEntão praticamente estaremos lidando com variáveis o tempo\r\ninteiro!\r\nPara entender os 4 principais tipos de variáveis crie os seguintes\r\nobjetos no seu workspace:\r\nlogica <- TRUE\r\ntexto <- \"texto\"\r\nnumerico <- 1\r\nfator <- as.factor(c(“Eu”, “Sou”, “um”, “fator”))\r\nCada objeto é interpretado de uma forma diferente pela linguagem,\r\nvamos usar a função class() para entender como cada\r\nvariável se comporta:\r\nclass()\r\nDigite o seguinte após criar os objetos:\r\nclass(logica)\r\nclass(texto)\r\nclass(numerico)\r\nclass(fator)\r\nVocê deve obter as seguintes respostas:\r\n[1] \"logical\"\r\n[1] \"character\"\r\n[1] \"numeric\"\r\n[1] \"factor\"\r\nCada objeto pertence à uma classe diferente, portanto deve ser\r\ntratado como tal.\r\nO que cada estrutura\r\ndessas significa?\r\nlogical\r\nlogical (ou lógica): Boolean/binary (Booleana ou\r\nBinária), é sempre TRUE ou FALSE\r\ncharacter\r\ncharacter (or string) (texto): texto simples,\r\nincluindo simbolos e números dentro de aspas \"texto\",\r\n\"isso é um texto\",\r\n\"1ss0 também é um t3xt0\".\r\nnumeric\r\nnumeric (numérico): Literalmente números.\r\nOperadores matemáticos podem ser usados aqui.\r\nLembrando que na verdade as linguagens de programação não passam de\r\ncalculadoras chiques que podem:\r\n+ adicionar\r\n- subtrair\r\n* multiplicar\r\n/ dividir\r\n^ exponenciar\r\nfactor\r\nfactor (fator): Números ou strings (texto)\r\nORDENADOS de alguma forma\r\nIsso é um fator:\r\nas.factor(c(\"Eu\", \"sou\", \"um\", \"fator\"))\r\nIsso também é um fator:\r\nas.factor(c(1, 2, 3, 4))\r\nA palavra ORDEM é a mais importante para definir fatores.\r\nEssas são as 4 principais estruturas que aparecerão em suas\r\nanálises!\r\nEspero ter ajudado!\r\nMe segue no twitter: @gimbgomes\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2022-05-01T07:27:30-03:00",
    "input_file": "sobre-a-estrutura-das-variveis.knit.md"
  },
  {
    "path": "posts/2022-04-18-grouping-and-counting-in-the-tidyverse/",
    "title": "Grouping and counting in the tidyverse",
    "description": "In this post, I will show you how to group and count your data to generate\nsome stats. During an analysis it's pretty common to spend some time with EDA.",
    "author": [
      {
        "name": "Guilherme Bastos Gomes",
        "url": "https://gbastosg.github.io/guilhermesportfolio/"
      }
    ],
    "date": "2022-04-18",
    "categories": [],
    "contents": "\r\nHello!\r\nA pretty important concept to analise data it’s the EDA\r\n\r\nEDA stands for Exploratory Data Analysis\r\n\r\nWe do an EDA by using functions that helps us understand our data,\r\nand also with graphs that we are going to develop in future time.\r\nIn\r\nthis post I’m going to show you how to use the following functions for\r\ndata analysis and manipulation:\r\ncount()\r\nsummarise()\r\ngroup_by()\r\ntop_n()\r\n\r\nJust a reminder that in\r\nthis post I’ve wrote about the following functions:\r\nselect()\r\narrange()\r\nfilter()\r\nmutate()\r\n\r\nOk, since we are dealling with the tidyverse don’t\r\nforget to load it in your space:\r\nlibrary(tidyverse)\r\nwe will continue to use the iris data set that is\r\nalready built in R.\r\nPlanning the best way to\r\nproceed\r\nLet’s use the function count() to find the total number\r\nof each species in our data set.\r\nhead(iris)\r\nThis should give you something like this:\r\nSepal.Length\r\nSepal.Width\r\nPetal.Length\r\nPetal.Width\r\nSpecies\r\n5.1\r\n3.5\r\n1.4\r\n0.2\r\nsetosa\r\n4.9\r\n3.0\r\n1.4\r\n0.2\r\nsetosa\r\n4.7\r\n3.2\r\n1.3\r\n0.2\r\nsetosa\r\n4.6\r\n3.1\r\n1.5\r\n0.2\r\nsetosa\r\n5.0\r\n3.6\r\n1.4\r\n0.2\r\nsetosa\r\n5.4\r\n3.9\r\n1.7\r\n0.4\r\nsetosa\r\nNotice that the column Species holds a value that can be\r\nused to form groups in our data set.\r\nWell, to a better understandment of the values from each column, and\r\nalso to create a strategy to deal with the data, just use the command\r\nglimpse()\r\nglimpse(iris)\r\nThis should give you something like this:\r\nRows: 150  \r\nColumns: 5  \r\n$ Sepal.Length <dbl> 5.1, 4.9, 4.7, 4.6, 5.0, 5~  \r\n$ Sepal.Width  <dbl> 3.5, 3.0, 3.2, 3.1, 3.6, 3~  \r\n$ Petal.Length <dbl> 1.4, 1.4, 1.3, 1.5, 1.4, 1~  \r\n$ Petal.Width  <dbl> 0.2, 0.2, 0.2, 0.2, 0.2, 0~  \r\n$ Species      <fct> setosa, setosa, setosa~    \r\nSeems that we have a column Species with names that we\r\ncan group, but what are those names? There are some ways to obtain this\r\nanswer, one of them is by using count()\r\ncount()\r\nBe a friend of this function, hahaha\r\nWe can use it as:\r\niris %>%\r\n  count(Species)\r\nNow you should have something like this:\r\nSpecies\r\nn\r\nsetosa\r\n50\r\nversicolor\r\n50\r\nvirginica\r\n50\r\nA column with the groups and another with the number of ocurrencies\r\nof each one in our data set.\r\nThere are 50 samples of each species: Iris setosa, Iris\r\nversicolor and Iris virginica\r\nCounting with weights\r\nIf we want to understand the frequency of another variable inside our\r\ncounting, we just put a comma in the function and call the argument\r\nwt = column_name\r\niris %>%\r\n  count(Species, wt = Petal.Length)\r\nArguments are useful ways of improving our analysis by using the full\r\npotential of a function. To read the arguments associated to a function,\r\njust call “?” with the name of the function inside of RStudio:\r\n?count()\r\nAll the docummentation related to the function should appear in a\r\nside window. It’s possible to see another cool argument of the\r\ncount() function, that is, sort (organize). The default is\r\nFALSE, but we can switch it to TRUE in the\r\nfollowing way:\r\niris %>%\r\ncount(Species, wt = Petal.Length, sort = TRUE)\r\nIn this way, we don’t need to use the\r\narrange()function:\r\nSpecies\r\nn\r\nsetosa\r\n73.1\r\nversicolor\r\n213.0\r\nvirginica\r\n277.6\r\nFlowers from the Iris virginica specie are much larger than\r\nthose from Iris setosa. Yey, information with only one\r\nfunction!\r\nOk, cool. But what could be the mean size of petals of these\r\nspecies?\r\nNow let’s gather some stats.\r\ngroup_by() e\r\nsummarise()/summarize()\r\nSome other functions that are really useful to understand our data\r\nset are group_by() and summarise() (or\r\nsummarize() for those who preffer the merican english)\r\nsummarise()\r\nThis function is really useful to explore and reduce data at the same\r\ntime, you will see that with it we can obtain different information from\r\nour data set:\r\niris %>%\r\n  # Summarising to find the minimum, maximum, and the mean Petal size in the whole data set\r\n  summarise(min_sepal = min(Sepal.Length),\r\n            max_sepal = max(Sepal.Length),\r\n            mean_sepal = mean(Sepal.Length))\r\nmin_sepal\r\nmax_sepal\r\nmean_sepal\r\n4.3\r\n7.9\r\n5.84\r\nIt’s also possible to have multiple information at the same time:\r\niris %>%\r\n  # Summarising to find the Min, Max, and the Mean Petal Size, also the Sepal size!\r\n  summarise(min_petal = min(Petal.Length),\r\n            max_sepal = max(Sepal.Length),\r\n            media_sepal = mean(Sepal.Length),\r\n            media_petal = mean(Petal.Length),\r\n            total_n = n())\r\nmin_petal\r\nmax_sepal\r\nmean_sepal\r\nmean_petal\r\ntotal_n\r\n1\r\n7.9\r\n5.843333\r\n3.758\r\n150\r\nPretty nice!\r\ngroup_by()\r\nNow if we want the same stats, but for groups, we can simply add the\r\nfunction group_by() to our pipe before\r\nsummarise():\r\niris %>%\r\n  # Using summarise combined with gorup_by\r\n  group_by(Species) %>% #now we will have stats for each group\r\n  summarise(min_petal = min(Petal.Length),\r\n            max_sepal = max(Sepal.Length),\r\n            mean_sepal = mean(Sepal.Length),\r\n            mean_petal = mean(Petal.Length))\r\nWe will have this table:\r\nSpecies\r\nmin_petal\r\nmax_sepal\r\nmean_sepal\r\nmean_petal\r\n1 setosa\r\n1\r\n5.8\r\n5.01\r\n1.46\r\n2 versicolor\r\n3\r\n7\r\n5.94\r\n4.26\r\n3 virginica\r\n4.5\r\n7.9\r\n6.59\r\n5.55\r\ntop_n()\r\nThis function help us find top values in our data:\r\niris %>%\r\n  group_by(Species) %>%\r\n  top_n(1, Sepal.Length)\r\nSepal.Length\r\nSepal.Width\r\nPetal.Length\r\nPetal.Width\r\nSpecies\r\n<dbl>\r\n<dbl>\r\n<dbl>\r\n<dbl>\r\n<fct>\r\n5.8\r\n4\r\n1.2\r\n0.2\r\nsetosa\r\n7\r\n3.2\r\n4.7\r\n1.4\r\nversicolor\r\n7.9\r\n3.8\r\n6.4\r\n2\r\nvirginica\r\nNow you have even more tools to analyse and manipulate data, hope\r\nthis was useful!\r\n\r\nIn a future post, I will write about these initials that appeared in\r\nour table: <dbl>, <fct>, <car>, etc…\r\n\r\nThank you for your time!\r\nFollow me on twitter: @gimbgomes\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2022-05-01T07:25:17-03:00",
    "input_file": "grouping-and-counting-in-the-tidyverse.knit.md"
  },
  {
    "path": "posts/2022-04-17-agrupar-e-contar-dados-com-tidyverse/",
    "title": "Agrupar e contar dados com tidyverse",
    "description": "Neste post, vou mostrar como agrupar e contar seus dados para gerar algumas estatísticas. Durante uma análise de dados é bem comum passar um tempo com EDA.",
    "author": [
      {
        "name": "Guilherme Bastos Gomes",
        "url": "https://gbastosg.github.io/guilhermesportfolio/"
      }
    ],
    "date": "2022-04-17",
    "categories": [],
    "contents": "\r\nOlá!\r\nUm conceito bastante importante para analisar dados é o de EDA\r\n\r\nEDA significa Exploratory Data Analysis, ou análise de dados\r\nexploratória\r\n\r\nIsso é feito tanto com funções que te ajudam a compreender seus\r\ndados, quanto com gráficos que vamos desenvolver futuramente.\r\nNeste\r\npost vou me ater às funções para manipulação de dados:\r\ncount()\r\nsummarise()\r\ngroup_by()\r\ntop_n()\r\n\r\nLembrando que neste\r\npost escrevi sobre as funções:\r\nselect()\r\narrange()\r\nfilter()\r\nmutate()\r\n\r\nOk, como estamos usando o tidyverse não se esqueça de\r\ncarregá-lo na memória:\r\nlibrary(tidyverse)\r\nContinuaremos usando o dataset iris que já está no seu\r\nR.\r\nPlanejando a melhor\r\nforma para proceder\r\nVamos usar a função count() para encontrar o número\r\ntotal de cada espécie no data set.\r\nhead(iris)\r\nEste comando deve te mostrar algo assim:\r\nSepal.Length\r\nSepal.Width\r\nPetal.Length\r\nPetal.Width\r\nSpecies\r\n5.1\r\n3.5\r\n1.4\r\n0.2\r\nsetosa\r\n4.9\r\n3.0\r\n1.4\r\n0.2\r\nsetosa\r\n4.7\r\n3.2\r\n1.3\r\n0.2\r\nsetosa\r\n4.6\r\n3.1\r\n1.5\r\n0.2\r\nsetosa\r\n5.0\r\n3.6\r\n1.4\r\n0.2\r\nsetosa\r\n5.4\r\n3.9\r\n1.7\r\n0.4\r\nsetosa\r\nPerceba que a coluna Species guarda um valor que pode\r\nser usado para agrupar nosso data set.\r\nPara compreender melhor o que há em cada coluna e como traçar uma boa\r\nestratégia para trabalhar com os dados, basta usar o comando\r\nglimpse()\r\nglimpse(iris)\r\nIsso deve te mostrar algo assim:\r\nRows: 150  \r\nColumns: 5  \r\n$ Sepal.Length <dbl> 5.1, 4.9, 4.7, 4.6, 5.0, 5~  \r\n$ Sepal.Width  <dbl> 3.5, 3.0, 3.2, 3.1, 3.6, 3~  \r\n$ Petal.Length <dbl> 1.4, 1.4, 1.3, 1.5, 1.4, 1~  \r\n$ Petal.Width  <dbl> 0.2, 0.2, 0.2, 0.2, 0.2, 0~  \r\n$ Species      <fct> setosa, setosa, setosa~    \r\nParece que temos uma coluna Species com nomes que\r\npodemos usar para agrupar, mas quais são esses nomes? Existem algumas\r\nformas para compreender isso, uma delas é usar a função\r\ncount()\r\ncount()\r\nFaça amizade com essa função, hahaha\r\nPodemos usá-la da seguinte forma:\r\niris %>%\r\n  count(Species)\r\nAgora você deve ter algo assim:\r\nSpecies\r\nn\r\nsetosa\r\n50\r\nversicolor\r\n50\r\nvirginica\r\n50\r\nUma coluna com os grupos e outra com número de ocorrências de cada no\r\nnosso data set.\r\nPerceba que existem 50 amostras de cada espécie: Iris\r\nsetosa, Iris versicolor e Iris virginica\r\nContagem com pesos\r\nSe quisermos entender a frequencia de outra variável dentro da\r\ncontagem basta colocarmos uma virgula e chamar o argumento\r\nwt = nome_da_coluna\r\niris %>%\r\n  count(Species, wt = Petal.Length)\r\nArgumentos são formas muito úteis de melhorar a análise e usar todo o\r\npotencial de uma função, para ler os argumentos associados à funções\r\nbasta chamar “?” junto com o nome da função dentro do RStudio:\r\n?count()\r\nToda a documentação relacionada a função deve aparecer numa janela ao\r\nlado. Nela é possível ver outro argumento bacana da função count(), o\r\nsort (organizar). O padrão é FALSE, mas podemos trocar para\r\nTRUE da seguinte forma:\r\niris %>%\r\ncount(Species, wt = Petal.Length, sort = TRUE)\r\nSpecies\r\nn\r\nsetosa\r\n73.1\r\nversicolor\r\n213.0\r\nvirginica\r\n277.6\r\nAs flores da espécies Iris virginica são muito maiores do\r\nque as da espécie Iris setosa. Yey, informação com apenas uma\r\nfunção!\r\nOk, maneiro. Mas qual será o tamanho médio das pétalas dessas\r\nespécies?\r\ngroup_by() e\r\nsummarise()/summarize()\r\nOutras funções muito úteis para compreender o data set são\r\ngroup_by() e summarise() (ou\r\nsummarize() para aqueles que curtem o mérican english)\r\nsummarise()\r\nEssa função é muito útil para explorar e reduzir o dado ao mesmo\r\ntempo, veja como com ela podemos obter diversas informações sobre nosso\r\ndataset:\r\niris %>%\r\n  # Resumindo para encontrar o minimo, máximo, e a média do tamanho de pétalas\r\n  summarise(min_sepala = min(Sepal.Length),\r\n            max_sepala = max(Sepal.Length),\r\n            media_sepala = mean(Sepal.Length))\r\nmin_sepala\r\nmax_sepala\r\nmedia_sepala\r\n4.3\r\n7.9\r\n5.84\r\nTambém é possível obter múltiplas informações ao mesmo tempo:\r\niris %>%\r\n  # Resumindo para encontrar o minimo, máximo, e a média do tamanho de pétalas\r\n  summarise(min_petala = min(Petal.Length),\r\n            max_sepala = max(Sepal.Length),\r\n            media_sepala = mean(Sepal.Length),\r\n            media_petala = mean(Petal.Length),\r\n            total_n = n())\r\nmin_petala\r\nmax_sepala\r\nmedia_sepala\r\nmedia_petala\r\ntotal_n\r\n1\r\n7.9\r\n5.843333\r\n3.758\r\n150\r\nBastante maneiro!\r\ngroup_by()\r\nAgora se quisermos as mesmas estísticas, mas para o grupos, basta\r\nadicionar a função group_by() antes de\r\nsummarise():\r\niris %>%\r\n  # Resumindo para encontrar o minimo, máximo, e a média do tamanho de pétalas\r\n  group_by(Species) %>% #agora teremos estatísticas por grupos\r\n  summarise(min_petala = min(Petal.Length),\r\n            max_sepala = max(Sepal.Length),\r\n            media_sepala = mean(Sepal.Length),\r\n            media_petala = mean(Petal.Length))\r\nTemos algo assim:\r\nSpecies\r\nmin_petala\r\nmax_sepala\r\nmedia_sepala\r\nmedia_petala\r\n1 setosa\r\n1\r\n5.8\r\n5.01\r\n1.46\r\n2 versicolor\r\n3\r\n7\r\n5.94\r\n4.26\r\n3 virginica\r\n4.5\r\n7.9\r\n6.59\r\n5.55\r\ntop_n()\r\nEssa função nos ajuda a encontrar os maiores valores do data set:\r\niris %>%\r\n  group_by(Species) %>%\r\n  top_n(1, Sepal.Length)\r\nSepal.Length\r\nSepal.Width\r\nPetal.Length\r\nPetal.Width\r\nSpecies\r\n<dbl>\r\n<dbl>\r\n<dbl>\r\n<dbl>\r\n<fct>\r\n5.8\r\n4\r\n1.2\r\n0.2\r\nsetosa\r\n7\r\n3.2\r\n4.7\r\n1.4\r\nversicolor\r\n7.9\r\n3.8\r\n6.4\r\n2\r\nvirginica\r\nAgora você tem mais algumas ferramentas para analisar e manipular\r\ndados, espero ter ajudado!\r\n\r\nNum próximo post falarei sobre essas siglas que aparecem em nossa\r\ntabela: como <dbl>, <fct>, <car>, etc…\r\n\r\nEspero que tenham gostado!\r\nMe segue no twitter: @gimbgomes\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2022-05-01T07:24:10-03:00",
    "input_file": "agrupar-e-contar-dados-com-tidyverse.knit.md"
  },
  {
    "path": "posts/2022-04-16-o-poder-do-tidyverse-manipulao-de-dados/",
    "title": "O poder do tidyverse: manipulação de dados",
    "description": "Vou traduzir alguns posts meus aqui, para poder ajudar outros falantes de português a entenderem e usarem R para manipular dados. O Tidyverse é um pacote bastante importante para manipulação de dados, pois é fácil de usar e aprender.",
    "author": [
      {
        "name": "Guilherme Bastos Gomes",
        "url": "https://gbastosg.github.io/guilhermesportfolio/"
      }
    ],
    "date": "2022-04-16",
    "categories": [],
    "contents": "\r\nOlá!\r\nNeste post vou te mostrar como usar alguns verbos básicos do\r\ntidyverse:\r\nselect()\r\narrange()\r\nfilter()\r\nmutate()\r\nTodos esses verbos também são funções para lidar com dados\r\ndo mundo real, mas como coletar esses dados pode ser bem complicado\r\nvamos usar um conjunto de dados (data set) do R.\r\nVamos dar uma olhada no data set iris que nos da medidas\r\nem centimetros do tamanho de sepalas e petalas de tres espécies de\r\nangiospermas: Iris setosa, Iris versicolor, e Iris\r\nvirginica.\r\nE claro, já que estamos lidando com o tidyverse, temos que carregar o\r\npacote:\r\nlibrary(tidyverse)\r\nVamos ver o data set:iris\r\nou só uma parte dele:head(iris)\r\nou apenas dar uma olhadinha para aqueles que curtem stats:glimpse(iris)\r\nPipe ‘%>%’ e select()\r\nAntes de tudo, vamos começar com o selecionar e já que estamos usando\r\no tidyverse, também começaremos a usar os pipes também\r\nconhecido como %>% ou |>, tudo depende do que\r\nvocê mais gosta de escrever.\r\nEntão para selecionar um conjunto de colunas que você queira, você\r\npode escrever:\r\niris %>% #aqui incluimos o dataframe iris no pipe para a proxima função\r\nselect(Sepal.Length, Species) #selecionando duas colunas do dataframe `Sepal.Length` e `Species`\r\nNote o pipe “%>%”, isso significa que a saída de uma função será\r\nusada como entrada para a próxima, e o primeiro pipe apenas inclui o\r\ndata set iris dentro da função\r\nselect(Sepal.Length, Species)\r\nTranquilo, certo?\r\nAgora você deve ter um data set um pouco menor, se quiser checar,\r\nbasta chamar o mesmo script de antes, mas com um pipe para a função\r\nhead() que mostra apenas as primeiras 10 linhas:\r\niris %>%\r\n  select(Sepal.Length, Species) %>%\r\n  head()\r\nApenas uma dica, isso também funcionaria:\r\nhead(select(iris, Sepal.Length, Species))\r\nVocê deve ter algo assim:\r\nSepal.Length\r\nSpecies\r\n5.1\r\nsetosa\r\n4.9\r\nsetosa\r\n4.7\r\nsetosa\r\n4.6\r\nsetosa\r\n5.0\r\nsetosa\r\n5.4\r\nsetosa\r\nPara melhorar nosso trabalho, devemos criar um objeto que recebe esse\r\ndata set menor:\r\nÉ bom nomear as coisas de acordo com o que elas são, neste caso to\r\nusando o seguinte nome: selected_iris\r\nselected_iris <- iris %>%\r\n  select(Sepal.Length, Species) %>%\r\n  head()\r\narrange()\r\nSuponha que você queira dar uma rápida olhada na distribuição de\r\ntamanhos de sepalas ordenadas, podemos tanto chamar a função\r\nview() no RStudio, ou usar a função\r\narrange():\r\narrange(selected_iris) %>%\r\n  head()\r\nVoce deve ver algo assim:\r\nSepal.Length\r\nSpecies\r\n4.3\r\nsetosa\r\n4.4\r\nsetosa\r\n4.4\r\nsetosa\r\n4.4\r\nsetosa\r\n4.5\r\nsetosa\r\n4.6\r\nsetosa\r\narrange(desc())\r\nVoce notará que o dataframe agora está em ordem, dos\r\nmenores para o maiores valores de tamanho de sepalas (sepalas são\r\naquelas folhas que apoiam as petalas). Mas, e se quisessemos ordenar em\r\nordem descendente? Para isso precisamos usar a função\r\ndesc() dentro da função arrange():\r\narrange(desc(selected_iris)) %>%\r\n  head()\r\nAgora temos:\r\nSepal.Length\r\nSpecies\r\n7.9\r\nvirginica\r\n7.7\r\nvirginica\r\n7.7\r\nvirginica\r\n7.7\r\nvirginica\r\n7.7\r\nvirginica\r\n7.6\r\nvirginica\r\nfilter()\r\nBeleza, agora que sabemos select() e\r\narrange(), bora aprender mais dois outros verbos que também\r\nsão ótimos para manipulação e análise de dados:\r\nPrimeiro,\r\nvamos usar o filtro ou filter() para filtrar apenas a\r\nespécie Iris virginica do nosso dataset:\r\niris %>%\r\n  filter(Species == \"virginica\")\r\nNote que estamos usando o operador ==, que significa:\r\nqueremos filtrar tudo da coluna Species que seja igual ao\r\nnosso texto (note as aspas) “virginica”.\r\nSuponha\r\nque você queira filtrar apenas aqueles que NÃO são Iris\r\nvirginica:\r\niris %>%\r\n  filter(Species != \"virginica\")\r\nAgora usamos o operador != que significa diferente ou\r\ndesigual, sendo assim recebemos um data set com Iris setosa e\r\nIris versicolor apenas, para checar a veracidade, vamos criar\r\nobjetos que recebem nossos data set filtrados:\r\niris_virginica <- \r\n  iris %>%\r\n  filter(Species == \"virginica\")\r\n  \r\n  #And let's create the other one\r\n  \r\nnot_iris_virginica <-\r\n  iris %>%\r\n  filter(Species != \"virginica\")\r\nChecar usando operadores\r\ncondicionais\r\nAmbos operadores == (igual a) e !=\r\n(diferente de) podem ser usados em multiplas situações no R, por exemplo\r\npara checar se nosso filtro deu certo:\r\n#Veja que interessante essa forma da função select:\r\nselect(iris_virginica, Species) == \"virginica\"\r\nIsso deve retornar TRUE para todas as linhas dentro do\r\nnosso dado. Quando testamos nossas afirmativas com condicionais, o R\r\npode dizer se é TRUE ou FALSE\r\n(VERDADEIRO ou FALSO).\r\nVamos tentar mais uma:\r\n#chamando o data set dentro da função de novo:\r\nselect(not_iris_virginica, Species) == \"virginica\"\r\nAgora devemos receber apenas FALSE para todas as linhas\r\ndo nosso conjunto de dados not_iris_virginica. O que\r\nsignifica que nosso filtro deu certo, legal né?\r\nVou escrever sobre condicionais e todas essas paradas booleanas em\r\noutro post, já que existem muitos outros operadores poderosos\r\n(>=, <=, >,\r\n<, &, |, e por ai\r\nvai…)\r\nAgora vamos continuar com outros tidyverbo ;)\r\nmutate()\r\nO último e, talvez mais importante, verbo que vamos aprender é o\r\nmutate()\r\nEssa é uma ótima função para manipular, transformar e criar colunas\r\nem nosso dado\r\nmutate() funciona assim:\r\nmutate(coluna_que_quero_criar = equação)\r\nSuponha que queremos saber a razão entre o tamanho de pétalas e\r\nsepalas de todas as espécies:\r\niris %>%\r\n  mutate(ratio_petal_sepal = Petal.Length/Sepal.Length)\r\nExistem muitos outros usos para o verbo mutate, um deles é\r\nclassificar dados combinando com a função ifelse(), que\r\ncria uma condição dentro do mutate():\r\nQueremos classificar nossas flores como “grandes” ou “pequenas”,\r\nbaseado na razão obtida anteriormente, isso significa que “se\r\nratio_petal_sepal < 0.5, então a coluna”size” recebe a tag\r\nsmall , caso contrário recebe a tag large:\r\niris %>%\r\n  mutate(ratio_petal_sepal = Petal.Length/Sepal.Length) %>%\r\n  mutate(size = ifelse(ratio_petal_sepal < 0.5, \"small\", \"large\"))\r\nPerceba que estamos usando um mutate duplo, isso não seria necessário\r\nse tivessemos criado um objeto anteriormente:\r\nratio_iris <- iris %>%\r\n  mutate(ratio_petal_sepal = Petal.Length/Sepal.Length)\r\nAgora temos o objeto ratio_iris e podemos compreender\r\ncomo mutate() funciona combinado com\r\nifelse():\r\nratio_iris %>%\r\n  mutate(size  = ifelse(ratio_petal_sepal < 0.5, \"small\", \"large\"))\r\nExplicando mutate()\r\ncombinado com ifelse()\r\nratio_iris %>% #botando o dado no cachimbo\r\n  mutate(size  = #chamando a função mutate e criando uma coluna chamada \"size\"\r\n  ifelse(ratio_petal_sepal < 0.5, #se essa afirmação for `TRUE` e o número dentro de ratio_petal_sepal for menor que 0.5\r\n  \"small\", #então a coluna \"size\" receberá a tag \"small\"\r\n  \"large\" #caso contrário receberá \"large\"))\r\nNo fim, teremos um data set completamente marcado com a nossa\r\ncondição, num próximo post vou mostrar como você pode usar a função\r\ncount() para obter algumas estatísticas do nosso data set. Espero que\r\nvocê tenha gostado.\r\nSabendo que o conteúdo é escasso, vou tentar sempre traduzir alguns\r\nposts meus.\r\nTente usar essas quatro funções em outros data sets do R, como no\r\nmpg!\r\nObrigado por ter chegado até\r\naqui :)\r\nMe segue no twitter: @gimbgomes\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2022-05-01T07:22:49-03:00",
    "input_file": "o-poder-do-tidyverse-manipulao-de-dados.knit.md"
  },
  {
    "path": "posts/2022-04-13-the-power-of-the-tidyverse-manipulating-data/",
    "title": "The power of the tidyverse: manipulating data",
    "description": "In this post I will show you how to use the basic tools from tidyverse. This tools are useful to deal with a whole sort of data.",
    "author": [
      {
        "name": "Guilherme Bastos Gomes",
        "url": "https://gbastosg.github.io/guilhermesportfolio/"
      }
    ],
    "date": "2022-04-13",
    "categories": [],
    "contents": "\r\nHello!\r\nIn this post I will show you how to use the basic verbs of the\r\ntidyverse:\r\nselect()\r\narrange()\r\nfilter()\r\nmutate()\r\nAll these verbs are also great functions to deal with data\r\nfrom the real world, but since gathering this data can be very time\r\nuseful we will use a built in data set from R.\r\nLet’s have a look in the Iris data set which gives the measurements\r\nin centimeters of the variables sepal length, sepal width, petal length\r\nand petal width, respectively, for 50 flowers from each of 3 species of\r\niris. The species are Iris setosa, Iris versicolor,\r\nand Iris virginica.\r\nAnd of course since we are dealing with the tidyverse we have to load\r\nit:\r\nlibrary(tidyverse)\r\nwe can call it and have a look:iris\r\nor just a part of it:head(iris)\r\nor just a glimpse for those who love stats:glimpse(iris)\r\nPipe ‘%>%’ and select()\r\nFirst of all let’s start with select and since we are using a\r\ntidyverse way of thinking, we are going to start using pipes\r\nalso known as %>% or |>, depending on which you\r\nprefer to write.\r\nSo, to select a sort of columns you wish you can:\r\niris %>% #here we are calling the dataframe iris and piping to the next function\r\nselect(Sepal.Length, Species) #here we are calling the function and  choosing two columns `Sepal.Length` and `Species`\r\nNote the pipe “%>%”, that means that the output of one function\r\nwill be the input of the next one, and the first pipe just includes the\r\niris data set into the next function\r\nselect(Sepal.Length, Species)\r\nPretty easy, right?\r\nNow you should have a smaller data set, only the selected columns\r\nfrom iris to work with, if you want to check it, just call the same\r\nscript again, but using the head() function to see only the\r\nfirst 10 lines:\r\niris %>%\r\n  select(Sepal.Length, Species) %>%\r\n  head()\r\nJust a tip, this would also work (but it’s harder to read):\r\nhead(select(iris, Sepal.Length, Species))\r\nNow you should have something like this:\r\nSepal.Length\r\nSpecies\r\n5.1\r\nsetosa\r\n4.9\r\nsetosa\r\n4.7\r\nsetosa\r\n4.6\r\nsetosa\r\n5.0\r\nsetosa\r\n5.4\r\nsetosa\r\nTo make our work even easier, we should create an object with our\r\nsmaller iris dataframe:\r\nIt’s good to name it as it is, in this case I will use the following\r\nname: selected_iris\r\nselected_iris <- iris %>%\r\n  select(Sepal.Length, Species) %>%\r\n  head()\r\narrange()\r\nSuppose you want now to quick check the ordered distribution of Sepal\r\nLengths, we can either call the view() function inside\r\nRStudio, or use the arrange() function, like this:\r\narrange(selected_iris) %>%\r\n  head()\r\nYou should have something like this:\r\nSepal.Length\r\nSpecies\r\n4.3\r\nsetosa\r\n4.4\r\nsetosa\r\n4.4\r\nsetosa\r\n4.4\r\nsetosa\r\n4.5\r\nsetosa\r\n4.6\r\nsetosa\r\narrange(desc())\r\nYou will notice that the dataframe is now ordered from\r\nthe lowest to the highest values of Sepal.Length. But what if we wanted\r\nto arrange in a descending order? Then we should just use the function\r\ndesc() inside of our arrange() calling:\r\narrange(desc(selected_iris)) %>%\r\n  head()\r\nNow you will have:\r\nSepal.Length\r\nSpecies\r\n7.9\r\nvirginica\r\n7.7\r\nvirginica\r\n7.7\r\nvirginica\r\n7.7\r\nvirginica\r\n7.7\r\nvirginica\r\n7.6\r\nvirginica\r\nfilter()\r\nAlright, so now that we already know how to select() and\r\narrange(), let’s learn another two verbs that are great for\r\ndata manipulation and analysis:\r\nFirst\r\nof all, let’s use the filter() function to gather only\r\nIris virginica species from our dataset:\r\niris %>%\r\n  filter(Species == \"virginica\")\r\nNote that we are using the == operator, meaning we want\r\nto filter everything from the Species column that is equal to our text\r\n“virginica”.\r\nSuppose\r\nyou want to filter only those that are not Iris virginica:\r\niris %>%\r\n  filter(Species != \"virginica\")\r\nNow we have used the != which stands for different or\r\nnot equal, then we will have received a data set with Iris\r\nsetosa and Iris versicolor species, and to check if this\r\nis true, let’s create objects that receives our filtered data sets:\r\niris_virginica <- \r\n  iris %>%\r\n  filter(Species == \"virginica\")\r\n  \r\n  #And let's create the other one\r\n  \r\nnot_iris_virginica <-\r\n  iris %>%\r\n  filter(Species != \"virginica\")\r\nChecking with conditional\r\noperators\r\nBoth of these operators == (equal) and !=\r\n(not equal) can be used in different contexts in R, for example to check\r\nif everything was okay with our filtering:\r\n#here I am going to use another form of the select funcion:\r\nselect(iris_virginica, Species) == \"virginica\"\r\nAnd this should return TRUE for all the rows inside our\r\ndata set. When we test our affirmations with conditionals, R can check\r\nif that is TRUE or FALSE.\r\nLet’s try another one:\r\n#just calling the data set inside the function again:\r\nselect(not_iris_virginica, Species) == \"virginica\"\r\nAnd now you should receive FALSE for all the rows inside\r\nour not_iris_virginica data set. Meaning our filter worked,\r\ncool right?\r\nI will talk about conditionals and all those boolean things in\r\nanother post, since there are many other operators (>=,\r\n<=, >, <,\r\n&, |, and so on…)\r\nNow I am going to continue with another tidyverb ;)\r\nmutate()\r\nThe last and, maybe most important, function we are going to learn is\r\nmutate()\r\nThis is a great function to manipulate data and to transform or\r\ncreate new columns in our data set\r\nmutate() works like this:\r\nmutate(column_you_want_to_create = equation)\r\nSuppose you want to know the ratio between Petal and Sepal length of\r\nall the species:\r\niris %>%\r\n  mutate(ratio_petal_sepal = Petal.Length/Sepal.Length)\r\nThere are many uses for the mutate verb, another one is to sort data\r\ncombining it with the ifelse() function, which creates a\r\ncondition:\r\nImagine we want to classify our flowers as being “large” or “small”\r\nbased on our ratio, that means “if ratio_petal_sepal < 0.5, then it\r\nreceives a small tag, otherwise it receives a\r\nlarge tag:\r\niris %>%\r\n  mutate(ratio_petal_sepal = Petal.Length/Sepal.Length) %>%\r\n  mutate(size = ifelse(ratio_petal_sepal < 0.5, \"small\", \"large\"))\r\nCheck that we are using a double mutate calling, just because we have\r\nnot created an object, let’s tidy it:\r\nratio_iris <- iris %>%\r\n  mutate(ratio_petal_sepal = Petal.Length/Sepal.Length)\r\nNow we have the object ratio_iris and I can explain how\r\nmutate()combined with ifelse() works:\r\nratio_iris %>%\r\n  mutate(size  = ifelse(ratio_petal_sepal < 0.5, \"small\", \"large\"))\r\nExplaining mutate()\r\ncombined with ifelse()\r\nratio_iris %>% #putting the data set through our pipe\r\n  mutate(size  = #calling mutate and creating the column \"size\"\r\n  ifelse(ratio_petal_sepal < 0.5, #if this statement is `TRUE` and the number inside of ratio_petal_sepal is lesser than 0.5\r\n  \"small\", #then the column \"size\" will receive that tag \"small\"\r\n  \"large\" #else or otherwise it will receive \"large\"))\r\nYou will have a complete sorted data set, on the next post I will\r\nshow you how to count() and to gather some stats from data. Hope you\r\nliked.\r\nNow you can manipulate data and start a data analysis project using\r\nthe tidyverse\r\nTry using those functions in the other data sets from R, like the\r\nmpg for example!\r\nThank you for your time :)\r\nFollow me on twitter: @gimbgomes\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2022-05-01T05:19:20-03:00",
    "input_file": "the-power-of-the-tidyverse-manipulating-data.knit.md"
  },
  {
    "path": "posts/2022-04-11-testing/",
    "title": "Testing!",
    "description": "This is my first post, it is a test so there's nothing in it besides text and\nstuff. You know what, I am going to write something... Nah, changed my mind,\nlet's just keep this a test, sorry.",
    "author": [
      {
        "name": "Guilherme Bastos Gomes",
        "url": "https://gbastosg.github.io/guilhermesportfolio/"
      }
    ],
    "date": "2022-04-11",
    "categories": [],
    "contents": "\r\nDistill is a publication format for scientific and technical writing, native to the web.\r\nLearn more about using Distill at https://rstudio.github.io/distill.\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2022-04-11T05:54:41-03:00",
    "input_file": {}
  },
  {
    "path": "posts/welcome/",
    "title": "Welcome to My Portfolio!",
    "description": "This is where I am going to post everything I did using R and other programming languages!",
    "author": [
      {
        "name": "Guilherme Bastos Gomes",
        "url": "https://gbastosg.github.io/guilhermesportfolio/"
      }
    ],
    "date": "2022-04-11",
    "categories": [],
    "contents": "\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2022-04-11T05:53:57-03:00",
    "input_file": {}
  }
]
